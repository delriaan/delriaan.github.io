---
title: 'Dataset Design: Temporal Concurrency - Who & When'
author: "Chionesu George"
date: 2023-10-31
slug: who-and-when
series: 
  - Dataset Design and Temporal Concurrency
categories:
  - Data Engineering
  - Theory
tags:
  - analytics
  - engineering
  - time
  - data
  - semantics
toc:
  toc_depth: 3
  toc_float: true
---

{{% blogdown/jquery %}}

```{r SETUP, echo=FALSE}
#| label: SETUP
#| echo: false
knitr::opts_chunk$set(echo = FALSE);
options(article="dataset-design-and-temporal-concurrency");
source(file = "setup.R", local = environment());
tags$link(rel="stylesheet", href="/markdown.css");
tags$script(src = "/markdown.js");
last_mod
```

Welcome back!

Before getting started, let's revisit out problem statement from the introduction:

```{r}
#| label: PROBLEM_STATEMENT
problem_statement
```

The conventions I'll use are also defined in the introduction [here](../introduction#definitions--conventions){target='_blank'}.

## When

Identifying the global temporal window ( $W$ ) is important as defines the frame of reference within which temporal relations are queried and transformed. It is the absolute governor of detecting *when* things take place.  In this case, the window is defined as all records having temporal columns or derived temporal measurements with at least *one* value falling within the period *2019-01-01* to *2020-12-31*:

[ $\forall W, D^Î» \Rightarrow D^\lambda_\Omega:= \Bigg\{\matrix{ W_\text{start} \le \delta^T \le W_\text{end},\enspace\enspace\#\delta^T= 1\\ \\ W_\text{start} \le \delta^T_\text{end} \wedge W_\text{end} \ge \delta^T_\text{start},\enspace\enspace\#\delta^T= 2 }\Bigg\}$ ]{.mathblock}

, where $D^\lambda$ is the data source for context $\lambda$ (i.e., *demographics*, *claims*, *prescriptions*) and $W$ the lower and upper dates of the global window. The first form of $D^\lambda$ above reflects the case of a *single* time column in $D$ and the second form when there are two.

```{r}
drop_hint("Regarding the second form:", context = "posthoc", toggleGroup = 0)
```

- It allows for a much more compact dataset. I recommend giving serious consideration to transforming the single-date form into the dual-date form, especially when most of $\delta^I$ is duplicative along $\delta^T$ (more on this in a future article)
- It allows for $\delta^T$ to extend outside of the bounds of $W$ while preserving the ability to detect temporal concurrency relative to $W$
- ***Do not*** use the following logic to detect concurrency of the dual-date form with $W$ (or any other dual-date range):<br>[ $(W_\text{start} \le \delta_\text{start} \le W_\text{end} ) \wedge (W_\text{start} \le \delta_\text{end} \le W_\text{end})$ ]{.mathblock} This logical statement **will** fail to capture cases where $\delta^T$ extends outside of $W$:<br><br>`r window_example.png`

## Who

The "Who" aspect of the problem statement consists of two detectable conditions (as indicated by the conjunction *"and"*) and a possible, third:

- [ $\omega_1$]{.bigMath}: ["... members between 30 and 50 years old"]{.speech #omega-1-def}
- [ $\omega_2$]{.bigMath}: ["... have had at least two Inpatient visits within a six-week period"]{.speech #omega-2-def}
- [ $\omega_3$]{.bigMath}: $f(\omega_1, \omega_2)$ &mdash; [hierarchical concurrency]{.speech #omega-3-def}

### [Age vs. Report Window]{#omega-1} ([ $\omega_1$]{.medMath omega_id=1}) 

[ $\omega_1$]{.medMath omega_id=1} is the first opportunity to greatly trim down your data pull.

```{r}
drop_hint("It also presents a great case-in-point as to why carefully reading over a request <i>before</i> thrashing away at the keyboard is important:", context = "posthoc", toggleGroup = 1)
```

- [ $\omega_1$]{.medMath omega_id=1} must qualified relative to [ $W$]{.medMath} and not ["as of today"]{.speech}. Granted: this is not *explicitly* stated, but think about it: ["... for the period between January first of 2019 and the end of 2020"]{.speech} is your cue. Of course, when in doubt, check with the requester just to be sure.
- [ $W$]{.medMath} covers *two* years which will result in *two* ages for each member not filtered out. **Question**: Which age should be returned at this point? My preference would be *neither* and instead return the dates of birth. *Age* is a derived measure and is only needed to qualify records at this point; *dates of birth* are the temporal attributes ([ $\delta^T$]{.medMath}) which should carried forward (I'll demonstrate this shortly).

![](/decorative_line.png){.decorative-line}

[ &#10024; ]{.bigMath style="color:#330033; "} At this stage, we've defined the first portion of ["Who"]{.speech} is related to the problem statement.  An advantage of starting here is that a maximally large cohort has been defined and can be stored in a table to which subsequent data can more efficiently be joined: $D_{\Omega}:=\Big\{\delta^T \cup \delta^I\Big\}_{i}$ 


```{r}
drop_hint("Here's the symbol taxonomy for columns: ", context = "definition", toggleGroup = 0)
taxonomy
```

### [Events vs. Report Window]{#omega-2} ([ $\omega_2$]{.medMath omega_id=2})


{{% blogdown/footer %}}
