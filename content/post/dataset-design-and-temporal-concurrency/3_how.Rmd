---
title: 'Dataset Design: Temporal Concurrency - How'
author: "Chionesu George"
date: 2024-01-23
date-modified: last-modified
slug: how
series: 
  - Dataset Design and Temporal Concurrency
categories:
  - Data Engineering
  - Theory
tags:
  - analytics
  - engineering
  - time
  - data
  - semantics
editor_options: 
  chunk_output_type: console
---

{{% blogdown/jquery %}}

```{r SETUP, echo=FALSE}
#| label: SETUP
#| echo: false

knitr::opts_chunk$set(echo = FALSE);

options(article="dataset-design-and-temporal-concurrency");

source(file = "setup.R", local = environment());

hourglass.png <- magick::image_read("C:/Users/sapie/GitHub/delriaan.github.io/static/hourglass.png");

break_time <- { tags$p(
  tags$hr(style = "border-bottom: solid 5px #555555; width:100%; ")
  , tags$span(
      style = "font-size:4em;"
      , class = "speech"
      , tags$img(
          src = "/hourglass.png"
          , caption="Take a Break!"
          , style="height:3em; vertical-align:text-top; margin-top:-50px; float:left"
          )
      , "Take a Break!"
      )
  , tags$hr(style = "border-top: solid 5px #555555; width:100%; ")
  )}

who_when_what <- data.frame(who = c(), who = c(), who = c(), who = c());

# HTML output (note that nothing is visible in the rendered page):
tags$link(rel="stylesheet", href="/markdown.css");

tags$script(src = "/markdown.js");

tags$span(style = "display: none;", taxonomy);
tags$span(style = "display: none;", id = "msg_W" , "Report Window");
tags$span(style = "display: none;", id = "msg_o1", "... members between 30 and 50 years old");
tags$span(style = "display: none;", id = "msg_o2", "... have had at least two inpatient visits within a six-week period");
tags$span(style = "display: none;", id = "msg_o3", "Dependence vs. Independence");
tags$span(style = "display: none;", id = "msg_h1", "Results by month");
tags$span(style = "display: none;", id = "msg_h2", "All services received and corresponding facilities");
tags$span(style = "display: none;", id = "msg_h3", "Member demographics");
tags$span(style = "display: none;", id = "msg_g1", "Average length of stay");
tags$span(style = "display: none;", id = "msg_g2", "Counts of lapses in medication adherence");
tags$span(style = "display: none;", id = "msg_g3", "Cumulative count of lapses in medication adherence");
tags$span(style = "display: none;", id = "msg_g4", "Number of unique members");
tags$span(style = "display: none;", id = "msg_g5", "Total expenditures")
```

[Welcome back!]{.decorativeText} 

In [Part 2](../what){target="blank"}, we discussed the quantitative building blocks of the problem statement we've been working with. In this final article, I'll cover the *how* of the problem statement, focusing on considerations of both design and implementation of the deliverable.

First, let's review the key criteria governing how to display or interact with results:

- [ $h_1$]{.bigMath}: [Results by month]{#msg_h1}

- [ $h_2$]{.bigMath}: [Services and facilities]{#msg_h2}
  
- [ $h_3$]{.bigMath}: [Member demographics]{#msg_h3} 

The relevant part of the problem statement is as follows: 

> $H$: ["... I need to see results by month; all services received and corresponding facilities; and member demographics."]{.quote}.

In keeping with the theme of temporal concurrency, the focus will be to explore the effect of our **how** criteria in expressing $\Big\langle$
[ $\gamma_1$]{msg_id=g1}, 
[ $\gamma_2$]{msg_id=g2}, 
[ $\gamma_3$]{msg_id=g3}, 
[ $\gamma_4$]{msg_id=g4}, 
[ $\gamma_5$]{msg_id=g5}
$\Big\rangle$ and $\Big\langle$
[ $W$]{msg_id=W}, 
[ $\omega_1$]{msg_id=o1},
[ $\omega_2$]{msg_id=o2},
[ $\omega_3$]{msg_id=o3} 
$\Big\rangle$ by 
$\Big\langle$
[ $h_1$]{msg_id=h1},
[ $h_2$]{msg_id=h2},
[ $h_3$]{msg_id=h3} 
$\Big\rangle$:

- $f(W, \omega_i)\to \gamma_j;$: ***What*** derived from ***who*** and ***when***

- $g(\gamma_j, h_k):= R_{\gamma\times h}$: The $\gamma$ by $h$ report matrix defining ***how*** the metrics are aggregated.

Now for the fun part: If $h$ were limited to $h_2$ and $h_3$, the report matrix $R$ would be quite straight-forward to derive, appropriately aggregating $\gamma_j$ by each $h$. 

**That's not the fun part.**  &#128527;

The fun part is that $h_1$ is a time-based requirement that adds a layer of complexity to the report matrix depending on the metric. For example, let's consider [ $\gamma_4$]{msg_id=g4}. This is a clean, easy metric to aggregate across each of the $h$'s. However, [ $\gamma_1$]{msg_id=g1} is a bit more complex.

![](/decorative_line.png){.decorative-line}

{{% blogdown/footer %}}