---
title: 'Dataset Design: Temporal Concurrency - How'
slug: how
date: 2024-01-23
date-modified: last-modified
author: "Chionesu George"
params:
  - dateForm = Jan 2020
series: 
  - Dataset Design and Temporal Concurrency
categories:
  - Data Engineering
  - Theory
tags:
  - analytics
  - engineering
  - time
  - data
  - semantics
toc:
  - depth: 2
  - float: true
editor_options: 
  chunk_output_type: console
---

{{% blogdown/jquery %}}

```{r SETUP, echo=FALSE}
#| label: SETUP
#| echo: false

knitr::opts_chunk$set(echo = FALSE);

options(article="dataset-design-and-temporal-concurrency");

source(file = "setup.R", local = environment());

hourglass.png <- magick::image_read("C:/Users/sapie/GitHub/delriaan.github.io/static/hourglass.png");

break_time <- { tags$p(
  tags$hr(style = "border-bottom: solid 5px #555555; width:100%; ")
  , tags$span(
      style = "font-size:4em;"
      , class = "speech"
      , tags$img(
          src = "/hourglass.png"
          , caption="Take a Break!"
          , style="height:3em; vertical-align:text-top; margin-top:-50px; float:left"
          )
      , "Take a Break!"
      )
  , tags$hr(style = "border-top: solid 5px #555555; width:100%; ")
  )}

who_when_what <- data.frame(who = c(), who = c(), who = c(), who = c());

# Report Window: 
W <- map(c(5, 90), \(x){
    xend = x; 
    y = -5; 
    yend = 30; 
    color = I("#000000");
    line = list(width = 5);
    name = ifelse(x == 5, "W (start)", "W (end)");
    showlegend = FALSE;
    mget(ls());
  });

# Monthly Breakout (criteria h_1): 
M <- map(seq(0, 100, 25), \(x){
    xend = x; 
    y = -50; 
    yend = 50; 
    color = I("#555555");
    line <- list(dash = "dash");
    opacity = 0.2;
    name = ""; 
    showlegend = FALSE;
    mget(ls());
  });

# Member Events: 
E <- local({
  # Generate the number of members:
  mbrs <- rlang::set_names(
    transpose(list(
      c("circle", "diamond", "square", "hexagon", "triangle-up")
      , sample(colors(distinct = TRUE), 5) |> plotly::toRGB()
      ))
    , glue::glue("Member {LETTERS[c(1:5)]}")
    );
  
  .max_events <- 5;
  
  # Define member events for each member:
  mbr_events <- replicate(
    length(mbrs), {
      .out <- replicate(
        sample(.max_events, 1)
        , c(sample(1:20, 1), sample(30:60, 1, prob = runif(n = length(30:60), 0.1, 0.5)))
        ) |> 
        as.vector() |> sort() |> matrix(ncol = 2, byrow = TRUE);
      
      cbind(seq_len(nrow(.out)), .out) |> array_branch(1);
    }, simplify = FALSE) |>
    rlang::set_names(names(mbrs));
  
  # For each member ...
  imap(mbr_events, \(events, legendgroup, offset){
    y <- offset[legendgroup] |> unname();
    
    # For each member event generate the code to render a segment ...
    imap(events, \(.event, name, y){
      legendgroup <- legendgroup;
      showlegend <- name == 1;
      if (showlegend){ name <- legendgroup }
      x <- .event[2];
      xend <- .event[3];
      hovertext <- glue::glue("<b>{legendgroup}</b><br>t<sub>{x}</sub> to t<sub>{xend}</sub>");
      hoverinfo <- "text"
      .k <- (1:length(events)) - median(1:length(events));
      yend <- y <- -2 + 3 * y + .k[.event[1]];
      color <- mbrs[[legendgroup]][[2]];
      stroke = I("#333333");
      mode <- "markers";
      marker <- list(symbol = mbrs[[legendgroup]][[1]], size = 15);
      mget(ls());
    }, y = y);
  }, offset = seq_along(mbr_events) |> rlang::set_names(names(mbr_events))) |>
  purrr::flatten();
});

p <- c(W, M, E) |> 
  reduce(.f = \(cur, nxt){
    rlang::expr(add_segments(p = cur, !!!nxt)) |> eval()
  }, .init = plot_ly(height = 720)) |>
  add_annotations(
    text = "W<sub>start</sub>"
    , x = 5, y = 1.05
    , xref = "plot", yref = "paper"
    , showarrow = FALSE
    , font = list(size = 16, color = "black")
    ) |>
  add_annotations(
    text = "W<sub>end</sub>"
    , x = 90, y = 1.05
    , xref = "plot", yref = "paper"
    , showarrow = FALSE
    , font = list(size = 16, color = "black")
    ) |>
  layout(
    margin = list(t = -5, b = -5)
    , paper_bgcolor = I("#999999")
    , xaxis = list(title = list(text = "<b>Time</b>: Report window (W) and h<sub>1</sub>")
                   , range = c(-5, 100)
                   , showgrid = FALSE, zeroline = FALSE, showline = FALSE, showticklabels = FALSE)
    , yaxis = list(title = list(text = "")
                   , range = c(-1, 15)
                   , showgrid = FALSE, zeroline = FALSE, showline = FALSE, showticklabels = FALSE)
    );
# HTML output (note that nothing is visible in the rendered page):
tags$link(rel="stylesheet", href="/markdown.css");
tags$script(src = "/markdown.js");
tags$span(style = "display: none;", taxonomy);
tags$span(style = "display: none;", id = "msg_W" , "Report Window");
tags$span(style = "display: none;", id = "msg_o1", "... members between 30 and 50 years old");
tags$span(style = "display: none;", id = "msg_o2", "... have had at least two inpatient visits within a six-week period");
tags$span(style = "display: none;", id = "msg_o3", "Dependence vs. Independence");
tags$span(style = "display: none;", id = "msg_h1", "Results by month");
tags$span(style = "display: none;", id = "msg_h2", "All services received and corresponding facilities");
tags$span(style = "display: none;", id = "msg_h3", "Member demographics");
tags$span(style = "display: none;", id = "msg_g1", "Average length of stay");
tags$span(style = "display: none;", id = "msg_g2", "Counts of lapses in medication adherence");
tags$span(style = "display: none;", id = "msg_g3", "Cumulative count of lapses in medication adherence");
tags$span(style = "display: none;", id = "msg_g4", "Number of unique members");
tags$span(style = "display: none;", id = "msg_g5", "Total expenditures")
```

[Welcome back!]{.decorativeText} 

In [Part 2](../what){target="blank"}, we discussed the quantitative building blocks of the problem statement we've been working with. In this closing article, I'll provide some considerations related to addressing temporal characteristics for the *how* of the problem statement.

## The Setup

First, let's review the key criteria governing how to display or interact with results:

> $H$: ["... I need to see results by month; all services received and corresponding facilities; and member demographics."]{.quote}.

- [ $h_1$]{.bigMath}: [Results by month]{#msg_h1}
- [ $h_2$]{.bigMath}: [Services and facilities]{#msg_h2}
- [ $h_3$]{.bigMath}: [Member demographics]{#msg_h3} 

The goal is to put everything covered so far together by expressing $\big\langle$
[ $\gamma_1$]{msg_id=g1}, 
[ $\gamma_2$]{msg_id=g2}, 
[ $\gamma_3$]{msg_id=g3}, 
[ $\gamma_4$]{msg_id=g4}, 
[ $\gamma_5$]{msg_id=g5} $\big\rangle$ and $\big\langle$
[ $W$]{msg_id=W}, 
[ $\omega_1$]{msg_id=o1},
[ $\omega_2$]{msg_id=o2},
[ $\omega_3$]{msg_id=o3} $\big\rangle$ in the context of $\big\langle$
[ $h_1$]{msg_id=h1},
[ $h_2$]{msg_id=h2},
[ $h_3$]{msg_id=h3} $\big\rangle$:

- $f(W, \omega_i)\to \gamma_j$

> ***What*** derived from ***when*** and ***who***

- $g(\gamma_j, h_k):= R_{\gamma\times h}$

> The $\gamma$ by $h$ report matrix defining ***how*** the metrics are aggregated.

## The Fun Part

If $h$ were limited to $h_2$ and $h_3$, the report matrix $R$ would be quite straight-forward to derive, appropriately aggregating $\gamma_j$ by each $h$. 

**That's not the fun part.**  &#128527;

The fun part is taking into account $h_1$ which adds a layer of complexity to the report matrix depending on the metric. 

- For example, consider [ $\gamma_4$]{msg_id=g4}, an easy metric to aggregate across each of $h_k$. 
- Contrast that with [ $\gamma_1$]{msg_id=g1}, which presents a temporal **windowing** problem with respect to [ $h_1$]{msg_id=h1} since both involve windows of time:

`r p`

Multiple members with multiple events spanning multiple segments of time. This hsould immediately raise some questions such as:

- How does one select the appropriate window of time for each member and event? 
   - By event end or beginning?
   - By any event within the monthly window? 
- How does one address multiple events for a single member within a monthly window?
- ***Bonus question***: Is the arithmetic mean the best way to aggregate the data in the first place?

Fortunately, the goal here isn't to resolve these questions but to illustrate the complexities of temporal concurrency at various levels. It's been my experience that dealing with the temporal aspects of an analytic use case can be very challenging requiring multiple iterations of discovery with business stakeholders. As a data practitioner, developing a sense of how time can affect an analytics initiative beforehand will make navigating those conversations with the business easier.

![](/decorative_line.png){.decorative-line}

## [&#127881;]{style="font-size:1.5em;"}[ Congratulations!]{.decorativeText} 

You've made it to the end of this series: just a few closing thoughts:

- I encourage you to get in the habit of framing your problem statements in terms of the ***what***, ***when***, ***who***, and ***how***. It's a simple way to ensure that you're considering the right questions at the right time (slight pun intended). Don't be in a rush to jump from problem statement to code: interrogate the problem statement like a 70's detective show.

- ***Always*** investigate how time affects your problem statement as it relates to **inclusion criteria**, **metrics derivation**, and **reporting**. The way you go about retrieving data or feature engineering can be greatly influenced by the temporal aspects of your problem.

- If possible, during the discovery phase of your analytics project, determine what form the results will take in the final data product:
   - Knowing this can help guide your thought process when considering how much data to wrangle and what engineering tasks should occur *within* the data product vs. upstream in the data pipeline.
   - This is especially important when there are temporal dynamics to the analysis tied to dynamically calculated metrics: an example would be moving averages, cumulative sums, etc. in an *interactive* dashboard that responds to user input such as filters, date range sliders, etc.

- Finally, dealing with temporal concurrency can be a real challenge, but don't back down from that challenge. Speaking from personal experience, once you become comfortable with the complexities of time, you'll find new ways to approach analytic initiatives and be able to enter into more complex problem spaces with confidence.

{{% blogdown/footer %}}